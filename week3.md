J071*김지성
J183*이민구
J228*임성균
J271*최재영

## 토론

퀘스트가 너무 무거우면 미션에 치여 사는 와중에 진행하기가 힘들다.

AI 모델들이 많은데 ChatGPT랑 Gemini를 비교해보았는데 Gemini가 좀 더 잘해주는 것 같다. - 사람마다 맞는 AI 모델이 있을 것 같다.

퀘스트를 미션 시작 전에 할지? 미션이 다 끝나고 할지?를 명시해주면 퀘스트를 진행하기 조금 더 수월할 수 있겠다.

2주차 퀘스트에서 너무 추상적인 미션은 보완하거나 제거하고, 좋다고 생각되는 퀘스트는 디벨롭을 해보는 방향으로 진행해보면 좋을 것 같다.

미션 관련 말고 주간 회고에 AI를 활용해보는 퀘스트도 좋지 않을까?

**AI 활용 경험**

J271(최재영)

- 개발 : ChatGPT를 이용해서 분석, 구현에 도움을 받는 정도외에는 미사용(다른 모델 사용 경험 無)

- 일상 : 어머님이 GPT로 사주를 봐준 적이 있음

J071(김지성)

- 개발 : 메서드를 정리하는 문서 작성
- 일상 : 뮤지컬 대본 및 가사 작성 도움

J183(이민구)

- 개발 : GPT에게 코드를 받으면 너무 읽기가 힘들어서, 정보를 얻는 용도로만 사용 -> 그렇다 보니 명확한 질문 보다는 두루뭉술한 질문을 많이 하게 됨 정확하게 뭘 원하는지 정의하고 정리하고 AI를 활용해야 원하는 답변을 얻을 수 있다고 생각

- 개발 관련해서 AI르 사용할 때는 cloude, gemini가 성능이 더 좋다고 생각함

J228(임성균)

- 개발 : 학습에 있어서 가장 많이 AI를 사용. 간단하게 학습할 정보들을 확인하는 용도로 사용하거나 공식 문서가 영어라면 해석해서 정리해달라는 용도로 많이 사용. 테스트 코드를 작성할 때도 범위를 지정해서 테스트 코드 예시를 받아서 가공한 경험

## 결론

- 개발자들은 개발 관련한 부분 외에서는 AI를 잘 활용하지 않는다.

- 개발을 하면서 진행할 수 있는 퀘스트와 일상에서 진행할 수 있는 퀘스트로 나눠보자

# 3주차 퀘스트

기존

## 1. 상황에 맞는 AI 고려하기

디벨롭

## 1. 🕹️ 여러 모델 AI에 질문하기

선정 배경

- 가장 사용화된 ChatGPT 외에도 많은 좋은 AI들이 있는데, 잘 모르는 사람들이 있다.
- 여러 AI를 사용해보고 어떤 상황에 어떤 AI가 좋은지 직접 몸으로 느껴봐야 한다.

목적

- 필요한 질문을 여러 모델 AI에 해보기
- AI들에게 받은 답변들을 비교해서 어떤 것이 더 도움이 됐는지 확인해보기

달성 기준

- 하나의 질문 선정
- 하나의 똑같은 질문을 주로 사용하는 AI와 다른 모델 AI에 물어보고 답변 받기 (⭐2개 이상!)
- 답변을 비교해보고 어느 것이 어떤 이유로 더 적절한 답변인지 본인의 생각 적기

## 🕹️ 퀘스트 2. 주간 회고를 첨부하여 다음 주 학습 전략 추천받기

선정 배경

- 매주 금요일 회고를 진행하고 다음 주에는 어떤 식으로 학습할지 전략을 생각한다.
- 하지만 회고를 기반으로 생각한 전략이 틀린 전략일 수도 있고, 미션에 치이다 보면 계획한 대로 수행하기 쉽지 않다.

목적

- AI에게 학습 전략을 추천 받고 체크리스트로 만들어 수행해보자.

달성 기준

- AI에게 1,2,3주차 회고 입력하기
- 입력한 회고를 바탕으로 다음 주에는 어떤 식으로 학습하면 좋을지 추천받기
- 나만의 TODO 리스트를 개인적으로 만들어서 달성할 때마다 표시하기

입력 EX.

```prompt
회고 1
~~
회고 2
~~
회고 3
~~

이 회고들을 바탕으로 다음주 미션을 수행할 때 가장 적합한 학습전략과 목표를 작성해줘.
```

답변 EX.

- 학습 전략
<img width="563" height="617" alt="image" src="https://github.com/user-attachments/assets/2d3c4daf-4a39-449a-8189-63585469d082" />
<img width="561" height="323" alt="image" src="https://github.com/user-attachments/assets/32474c48-4da3-4304-a81d-44c3d8649f46" />


- 이번주 목표
<img width="538" height="427" alt="image" src="https://github.com/user-attachments/assets/611d436b-732f-4034-804c-7e049e20dafc" />

## 🕹️퀘스트 3. AI를 활용해 더 깔끔한 문서화 도전하기(upgrade.ver for me)

선정 배경

- 2주차 미션에 있는 퀘스트인데, 모두가 해보고 싶을 정도로 좋은 퀘스트라고 생각해서 유지

목적

- 네부캠을 진행하면서 README 작성을 잘한다고 느끼는 분들이 많은데, 그런 분들의 형식을 참고하여 개인 README를 업그레이드하기

달성 기준(2주차 기준 유지)

- 자신이 생각하기에 잘 읽히고 잘 작성했다고 생각하는 다른 캠퍼분의 'README.md' 또는 '학습정리.md'를 AI에게 양식을 기억해달라고 한다.
- 자신이 작성한 'READMD.md' 또는 '학습정리.md'를 넣어서 내가 앞에서 넢은 캠퍼 분의 양식에 맞게 작성해달라고 요청한다.
- 결과적으로 문서의 <b>가독성</b>이 좋아졌는지에 대해서 평가해본다.
- 마지막으로 참고한 캠퍼분의 GIST에 감사의 댓글을 남긴다.

## 🕹️ 퀘스트 4. AI를 활용해 스트레스가 풀릴 수 있는 춤 추천받기

선정 배경

- 캠퍼분 중에서 개발을 하면서 받은 스트레스를 '춤'으로 푸는 분이 계심
- '춤'을 추면 기분이 나아지는 경험을 자주 했다고 함

목적

- 캠퍼분처럼 '춤'으로 스트레스를 풀어보자
- 어떤 춤을 추는 것이 스트레스 해소에 도움이 되는지 AI에게 추천 받기

달성 기준

- 개발로 인해 많은 스트레스를 받을 때 잠시 내려놓기
- AI에게 현재 스트레스 받는 상황을 입력하고 그 스트레스를 해소할 수 있는 춤 동작 영상 추천받기
- 1분간 따라해보고 Slack random 채널에 이 춤 좋아요 공유하기

EX.
https://chatgpt.com/share/688c61f1-145c-800e-a710-961025afc0a4


# 퀘스트 수행 계획
## J038_김민영

- **퀘스트**: 여러 모델 AI에 질문하기
- **선택한 이유**
    - chaptGPT, Gemini, 노트북LM 외에도 다른 AI가 있는지 알아보고 적재적소에 맞게 사용하고자 한다.
- **수행하기!**
  - 평소에 자주 사용하는 **chaptGPT**와 처음 사용해보는 **Claude**, **perplexity**에게 동일한 질문을 해보았다.
  - "HTTP 요청 및 응답 메시지에서 Content-Type, Content-Language, Content-Encoding가 있는 이유가 뭐야? 없으면 어떻게 달라져?"
    <details>
    <summary>chaptGPT 답변</summary>
    HTTP 요청 및 응답 메시지에서 `Content-Type`, `Content-Language`, `Content-Encoding` 헤더는 **클라이언트와 서버가 콘텐츠를 정확하게 이해하고 처리하기 위해 꼭 필요한 정보**를 담고 있어. 각각의 역할과, 만약 없을 때 어떤 문제가 생기는지를 아래에 정리해줄게.

    ---

    ### ✅ 1. `Content-Type`

    **역할**:
    콘텐츠의 \*\*MIME 타입(형식)\*\*을 명시함.
    예: `text/html`, `application/json`, `image/png`, `text/plain;charset=utf-8` 등

    **왜 필요한가?**

    * 브라우저나 서버가 **본문(body)의 데이터가 어떤 형식인지** 알아야 적절히 **파싱하거나 처리**할 수 있음.
    * 예를 들어 `application/json`이면 JSON 파서로, `text/html`이면 HTML 렌더링 엔진으로 처리해야 함.

    **없으면?**

    * 콘텐츠가 **어떤 형식인지 알 수 없음 → 잘못된 파싱**
    * 예: JSON 응답인데 `Content-Type`이 없으면 클라이언트가 단순 문자열로 처리하거나 에러 발생

    ---

    ### ✅ 2. `Content-Language`

    **역할**:
    콘텐츠가 **어떤 언어로 작성되었는지** 알려줌.
    예: `Content-Language: en`, `ko`, `fr`, `en-US`, `ko-KR`

    **왜 필요한가?**

    * 브라우저나 번역기, 접근성 도구(스크린 리더 등)가 **언어에 맞게 콘텐츠를 표시**하거나 처리
    * 검색 엔진이나 캐시 서버도 **언어별로 콘텐츠 분류** 가능

    **없으면?**

    * **다국어 콘텐츠 처리에 어려움**
    * 사용자 환경(예: 브라우저 설정 언어)과 맞지 않는 콘텐츠를 제공할 수 있음

    ---

    ### ✅ 3. `Content-Encoding`

    **역할**:
    본문 데이터를 **압축하거나 인코딩한 방식**을 명시함.
    예: `gzip`, `br`(Brotli), `deflate` 등

    **왜 필요한가?**

    * 클라이언트가 본문을 \*\*해독(decode)\*\*해서 원래의 콘텐츠를 얻을 수 있도록 도와줌
    * 네트워크 트래픽을 줄여서 성능 향상

    **없으면?**

    * 서버가 gzip으로 압축했는데 이 헤더가 없으면 클라이언트는 **압축된 바이너리를 그대로 출력**하거나 **깨진 내용으로 보일 수 있음**

    ---

    ### 📌 정리

    | 헤더                 | 역할           | 없을 경우 문제                 |
    | ------------------ | ------------ | ------------------------ |
    | `Content-Type`     | 콘텐츠 형식 명시    | 콘텐츠 해석 실패 (JSON, HTML 등) |
    | `Content-Language` | 콘텐츠 언어 명시    | 번역, 렌더링, 접근성에 오류 가능      |
    | `Content-Encoding` | 압축/인코딩 방식 명시 | 압축 해제 불가 → 깨짐            |

    ---

    필수는 아니지만, **정확한 콘텐츠 전달을 위해 매우 중요**한 헤더들이야. 특히 REST API나 다국어 웹사이트, 압축 전송 등에서는 필수처럼 사용돼.

    </details>

    <details>
    <summary>Claude 답변</summary>
    
    HTTP 헤더에서 Content-Type, Content-Language, Content-Encoding이 필요한 이유는 클라이언트와 서버가 전송되는 데이터를 올바르게 해석하고 처리하기 위해서입니다.

    ## 각 헤더의 역할

    **Content-Type**: 전송되는 데이터의 미디어 타입을 명시합니다. 예를 들어 `text/html`, `application/json`, `image/png` 등으로 데이터 형식을 알려줍니다.

    **Content-Language**: 콘텐츠의 언어를 나타냅니다. `ko-KR`, `en-US` 같은 값으로 사용자에게 적절한 언어로 콘텐츠를 표시할 수 있게 합니다.

    **Content-Encoding**: 데이터가 어떤 방식으로 압축되거나 인코딩되었는지 알려줍니다. `gzip`, `deflate`, `br` 등의 값으로 압축 해제 방법을 명시합니다.

    ## 헤더가 없을 때의 문제점

    이러한 헤더들이 없으면 다음과 같은 문제가 발생할 수 있습니다:

    **Content-Type이 없으면**: 브라우저나 클라이언트가 데이터를 어떻게 해석해야 할지 추측해야 합니다. HTML을 텍스트로 표시하거나, JSON을 다운로드 파일로 처리할 수 있습니다.

    **Content-Language가 없으면**: 다국어 사이트에서 적절한 언어 선택이 어려워지고, 검색 엔진이나 번역 도구가 언어를 잘못 판단할 수 있습니다.

    **Content-Encoding이 없으면**: 압축된 데이터를 받았을 때 어떻게 압축 해제해야 할지 몰라서 데이터가 깨지거나 처리할 수 없게 됩니다.

    결과적으로 이런 헤더들은 웹 통신에서 데이터의 정확한 해석과 효율적인 처리를 위한 필수적인 메타데이터 역할을 합니다.
    </details>
    <details>
    <summary>perplexity 답변</summary>

    HTTP 요청 및 응답 메시지에서 **Content-Type, Content-Language, Content-Encoding** 헤더가 존재하는 이유는 수신자가 본문(컨텐츠)을 올바르게 해석하고 처리할 수 있도록 필요한 정보를 제공하기 위해서입니다. 만약 이 헤더들이 없다면, 데이터가 무엇을 의미하는지, 어떤 언어인지, 그리고 어떤 방식으로 인코딩(압축)되어 있는지 알 수 없어 **정확한 처리와 표시가 어려워집니다**.

    ### 각 헤더의 역할

    - **Content-Type**: 본문 데이터의 형식(MIME 타입)을 명시합니다. 예를 들어 `text/html; charset=utf-8`은 HTML 텍스트이며 UTF-8로 인코딩됨을 나타냅니다. 이것이 없으면 브라우저나 수신 프로그램이 컨텐츠를 어떤 형식으로 해석해야 하는지 알 수 없으므로 내용을 잘못 표시하거나 아예 표시하지 못할 수 있습니다.[3][5]

    - **Content-Language**: 컨텐츠의 주 언어(예: `ko`, `en-US`)를 명시합니다. 수신자는 이를 참조해 언어 맞춤 처리를 할 수 있습니다. 이 정보가 없다면 다국어 환경에서 올바른 사용자 경험을 제공하기 어렵거나, 자동 번역 등 후처리에 혼동이 생길 수 있습니다.[5][8][3]

    - **Content-Encoding**: 본문에 적용된 압축 방식(예: gzip, deflate, br 등)을 표기합니다. 주로 데이터 용량을 줄이기 위해 압축한 후 사용합니다. 클라이언트는 이 값을 보고 적절하게 압축을 해제합니다. 이 값이 없다면 데이터가 압축되어 있음에도 압축 해제를 하지 못해 깨진 파일/텍스트로 보일 수 있습니다.[2][9][3]

    ### 헤더가 없는 경우의 변화

    - **Content-Type이 없다면**: 클라이언트가 데이터를 해석하는 기준이 없어, 예를 들어 이미지 파일을 텍스트로 보여주거나, JSON을 텍스트 파일처럼 보여주는 등 오류가 발생할 수 있습니다.
    - **Content-Language가 없다면**: 다양한 언어로 제공되는 서비스에서 언어별 처리가 어렵고, 자동 번역이나 렌더링 환경을 맞춤 제공하지 못합니다.
    - **Content-Encoding이 없다면**: 본문 데이터가 압축된 경우, 수신자가 압축 해제를 하지 않고 그대로 표시하여 데이터가 깨지게 됩니다. 또한 네트워크 전송 효율성이 크게 떨어집니다.

    ### 종합

    이 헤더들은 **HTTP 메시지의 본문 데이터 표현 정보를 명확히 지정**하여 올바른 데이터 해석, 사용, 그리고 최적화된 전송을 가능하게 합니다. 부재 시에는 데이터 해석 오류, 사용자 경험 저하, 불필요한 데이터 낭비 등이 발생할 수 있습니다.[1][2][3][5]

    [1] https://moon-seung-chan.tistory.com/15  
    [2] https://hippogrammer.tistory.com/191
    [3] https://www.zerocho.com/category/HTTP/post/5b3ba2d0b3dabd001b53b9db
    [4] https://developer.mozilla.org/ko/docs/Web/HTTP/Reference/Status
    [5] https://taehoung0102.tistory.com/170
    [6] https://httpd.apache.org/docs/current/ko/content-negotiation.html
    [7] https://velog.io/@alkwen0996/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-HTTP-%ED%97%A4%EB%8D%94-%EC%9D%BC%EB%B0%98
    [8] https://www.timegambit.com/blog/http/03-2
    [9] https://rob-coding.tistory.com/21
    [10] https://12bme.tistory.com/579
    
    </details>
  - "클라이언트가 중간에 끊어졌다가 다시 이어서 하려면 HTTP Session 정보처럼 세션을 구분하는 정보가 있다면 가능해?"
    <details>
    <summary>chaptGPT 답변</summary>
    
    좋은 질문이야.
    HTTP는 기본적으로 **비연결성(stateless)** 프로토콜이라 클라이언트가 연결을 끊으면 **서버는 그 상태를 기억하지 않아**. 하지만 **세션(session)이나 고유 식별자(token 등)를 이용하면 중단 후 재개하는 기능을 구현**할 수 있어.

    ---

    ## ✅ 세션 구분 정보를 이용해 "이어받기"를 가능하게 만드는 방식들

    ### 1. **세션 ID 또는 토큰 사용**

    * 서버가 클라이언트에게 고유한 **세션 ID** 또는 **access token**을 발급함
    * 클라이언트는 이후 요청마다 이 값을 포함시킴 (예: 쿠키, Authorization 헤더 등)
    * 서버는 이 ID를 기준으로 클라이언트 상태나 데이터를 식별

    🟢 **가능한 기능**:

    * 로그인 유지
    * 진행 상태 저장
    * 중간 요청 이후 이어서 처리

    ⚠️ 단점:

    * 서버가 상태(state)를 어느 정도는 기억해야 함 (stateful 처리)
    * 보안 이슈: 세션 탈취 등에 대한 대비 필요

    ---

    ### 2. **Range 요청 (HTTP Range Requests)**

    * 대용량 파일 다운로드처럼 **중단된 전송을 이어받을 때 사용하는 표준 방식**
    * 클라이언트는 `Range` 헤더를 이용해 **원하는 바이트 범위만 요청**

    ```http
    GET /file.zip HTTP/1.1
    Host: example.com
    Range: bytes=1000-
    ```

    🟢 서버는 `206 Partial Content` 응답과 함께 요청한 범위만 보내줌
    🟢 `Content-Range` 헤더를 응답에 포함시켜 이어받기 처리를 돕는다.

    ---

    ### 3. **애플리케이션 레벨에서 세션/상태 저장**

    * 예: 어떤 요청에서 사용자의 입력이나 처리 단계를 DB나 Redis 등에 저장해두고,
    * 다음 요청 시 클라이언트가 ID를 보내면 이전 상태부터 이어서 처리

    🟢 예시:

    ```json
    {
    "session_id": "abc123",
    "step": "3",
    "input": "사용자가 이전에 입력한 내용"
    }
    ```

    ---

    ## ❓그렇다면 클라이언트가 중간에 끊겼다 이어받으려면?

    가능함. 다만 **전제 조건**이 있어:

    | 조건           | 설명                                  |
    | ------------ | ----------------------------------- |
    | 세션을 구분할 정보   | 쿠키, 세션 ID, access token 등           |
    | 이어받을 수 있는 구조 | Range 지원, 이전 처리 상태 저장 구조            |
    | 상태 저장소       | 서버가 상태를 기억하거나 DB, Redis 등 외부 저장소 필요 |

    ---

    ## 📌 정리

    | 기술           | 이어받기 가능? | 용도                    |
    | ------------ | -------- | --------------------- |
    | 세션 ID / 토큰   | ✅        | 사용자 상태 유지, 재시도 처리     |
    | Range 요청     | ✅        | 파일 다운로드 이어받기          |
    | 애플리케이션 상태 저장 | ✅        | 사용자 요청 흐름 이어받기        |
    | 기본 HTTP만 사용  | ❌        | 상태 기억 안 됨 (stateless) |

    ---

    필요하다면 특정 상황(예: 영상 업로드, 다운로드 중단 후 재개, 다단계 설문 등)에 맞게 세션과 상태를 설계할 수 있어.
    어떤 사례에서 이어받기를 하려는 건지도 알려주면, 더 구체적으로 설명해줄 수 있어.

    </details>
    <details>
    <summary>Claude 답변</summary>
    
    HTTP Session 정보만으로는 **중간에 끊어진 요청을 이어서 하는 것**은 불가능합니다. 세션과 연결 복구는 서로 다른 개념이기 때문입니다.

    ## HTTP Session의 한계

    HTTP Session은 사용자의 **상태 정보**를 서버에 저장하는 메커니즘입니다. 로그인 상태, 장바구니 내용 등은 유지할 수 있지만, **진행 중이던 특정 요청**을 중단된 지점부터 재개하는 기능은 제공하지 않습니다.

    ## 연결이 끊어졌을 때 일어나는 일

    클라이언트와 서버 간 연결이 끊어지면:
    - 진행 중이던 HTTP 요청/응답은 **완전히 실패**합니다
    - 서버는 해당 요청에 대한 처리를 중단하거나 완료해도 클라이언트에게 전달할 수 없습니다
    - 클라이언트는 **처음부터 새로운 요청**을 보내야 합니다

    ## 이어서 하기 위한 실제 방법들

    **1. HTTP Range 요청 (파일 다운로드)**
    ```
    Range: bytes=500-1023
    ```
    파일 다운로드 시 특정 바이트 범위부터 이어받기가 가능합니다.

    **2. 애플리케이션 레벨에서 상태 관리**
    - 진행 상황을 데이터베이스나 캐시에 저장
    - 재연결 시 저장된 상태 정보로 이어서 처리

    **3. WebSocket이나 Server-Sent Events**
    - 연결 끊김을 감지하고 자동으로 재연결
    - 마지막 처리 지점부터 이어서 진행

    **4. 청크 단위 처리**
    - 큰 작업을 작은 단위로 나누어 각각 완료 상태를 추적

    결론적으로 HTTP Session은 사용자 상태는 유지해주지만, **끊어진 요청의 재개**는 별도의 메커니즘이 필요합니다.
    </details>
    <details>
    <summary>perplexity 답변</summary>

    클라이언트가 **중간에 연결이 끊긴 뒤에도 이어서 작업**하려면, HTTP처럼 연결 상태를 기본적으로 기억하지 않는(stateless) 프로토콜에선 **세션을 구분할 정보**가 반드시 필요합니다.  
    이때 각 사용자를 식별하고 상태를 이어받게 해주는 대표적인 방식이 **세션 ID**입니다.

    - **세션 아이디(session ID)**는 서버에서 클라이언트를 논리적으로 구분하기 위해 발급하는 식별자입니다.
    - 클라이언트는 이 세션 ID를 쿠키 등으로 저장해서, 요청마다 같이 전송합니다.
    - 서버는 세션 ID로 해당 사용자의 상태(예: 장바구니, 로그인 정보 등)를 찾아 이어서 처리할 수 있습니다.[2][5]

    만약 세션 ID 등 클라이언트 고유 식별 정보가 없다면, 서버는 **연결이 끊어진 뒤 동일 사용자가 다시 접속해도** 이전 상태를 알 수 없어 "처음부터 새로 시작"하게 됩니다.[1][6]
    반대로 **세션을 식별할 정보(세션ID, 토큰 등)가 있다면**,  
    - 클라이언트가 중간에 연결이 끊겼다가 다시 요청을 보내도,
    - 서버는 전달된 세션ID로 이전의 상태(작업 내역)를 찾아 이어서 처리할 수 있습니다.[8][2]

    정리하면,  
    - **세션 구분 정보가 있다면**: 끊김/재접속 상태에서도 이어서 작업 또는 처리가 가능해 집니다.
    - **세션 구분 정보가 없다면**: 끊겼다가 다시 접속할 때는 이전 상태를 기억하거나 복원할 방법이 없습니다. 항상 "초기 상태"로 간주합니다.

    [1] https://eh0322.tistory.com/84
    [2] https://yepchani.tistory.com/entry/HTTP-%EC%84%B8%EC%85%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
    [3] https://coding-factory.tistory.com/1012
    [4] https://www.ibm.com/docs/ko/wxs/8.6.1?topic=overview-http-session-management
    [5] https://f-lab.kr/insight/session-and-http-in-web-development
    [6] https://creamilk88.tistory.com/101
    [7] https://youngjinmo.github.io/2021/05/httpsession/
    [8] https://oh-sh-2134.tistory.com/111
    [9] https://velog.io/@thisyoon97/HTTP-Session%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90
    [10] https://pstudio411.tistory.com/entry/HTTP-%EC%84%B8%EC%85%98session
        
    </details>
  - "JSON format에서 표현할 수 있는 것과 표현하기 어려운 부분은 뭐야?"
    <details>
    <summary>chaptGPT 답변</summary>
    
    좋은 질문이야. JSON은 웹과 API에서 널리 사용되는 데이터 포맷이지만, **표현 가능한 것과 표현하기 어려운 것**이 명확히 구분되어 있어. 아래에 정리해줄게.

    ---

    ## ✅ JSON으로 **표현 가능한 것들**

    JSON은 기본적으로 **JavaScript 객체/배열 리터럴** 구조를 따르기 때문에 다음과 같은 **자료형과 구조**를 표현할 수 있어.

    | JSON 요소       | 설명               | 예시                                |
    | ------------- | ---------------- | --------------------------------- |
    | 객체 (Object)   | key-value 쌍의 집합  | `{ "name": "Minsu", "age": 25 }`  |
    | 배열 (Array)    | 값들의 리스트          | `[1, 2, 3]`, `[{"x":1}, {"x":2}]` |
    | 문자열 (String)  | 반드시 큰따옴표로 감싼 텍스트 | `"hello"`                         |
    | 숫자 (Number)   | 정수 또는 실수         | `42`, `3.14`                      |
    | 불리언 (Boolean) | 참/거짓             | `true`, `false`                   |
    | null          | 값 없음             | `null`                            |

    ---

    ## ❌ JSON으로 **표현하기 어려운 것들**

    ### 1. **함수 (Function)**

    * JavaScript에서는 가능하지만, JSON에서는 **함수 자체를 표현할 수 없음**
    * 예:

    ```js
    {
        "sayHello": function() { console.log("hi"); }  // ❌ JSON에서 불가능
    }
    ```

    ### 2. **날짜(Date)**

    * JSON에는 **날짜 타입이 없음**
    * 일반적으로 ISO 8601 문자열로 표현할 수는 있음
    → `"2025-08-07T10:00:00Z"`
    * 하지만 이건 **문자열**일 뿐이고, 파싱 후 `new Date()`로 다시 변환해야 함

    ### 3. **undefined / NaN / Infinity**

    * JSON에는 다음 값들이 **존재하지 않음**:

    * `undefined`
    * `NaN`
    * `Infinity`, `-Infinity`

    → JSON.stringify를 사용할 경우 자동으로 제거되거나 null 처리됨

    ### 4. **Symbol, BigInt (ES6 이상)**

    * `Symbol`은 고유 식별자로 JSON에 직렬화할 수 없음
    * `BigInt`도 숫자처럼 보여도 JSON에서는 오류 발생

    ### 5. **순환 참조 (Cyclic Reference)**

    * 객체 내부에 자기 자신을 참조하는 구조는 JSON으로 **직렬화할 수 없음**

    ```js
    const obj = {};
    obj.self = obj;
    JSON.stringify(obj); // ❌ TypeError 발생
    ```

    ---

    ## 🔎 기타 한계점

    | 한계         | 설명                                                   |
    | ---------- | ---------------------------------------------------- |
    | 키는 반드시 문자열 | 객체의 key는 반드시 문자열만 가능 (숫자나 심볼은 불가)                    |
    | 주석 불가      | JSON에는 주석을 달 수 없음 (`//` 또는 `/* */` 불가)               |
    | 타입 손실      | 날짜, Map, Set, 클래스 인스턴스 등은 stringify 시 단순 객체/문자열로 변환됨 |

    ---

    ## 🧠 정리

    | 구분  | 표현 가능                      | 표현 불가 또는 어려움                                 |
    | --- | -------------------------- | -------------------------------------------- |
    | 자료형 | 객체, 배열, 문자열, 숫자, 불리언, null | 함수, undefined, NaN, Infinity, Symbol, BigInt |
    | 구조  | 중첩 구조                      | 순환 참조                                        |
    | 기타  | ISO 날짜 문자열 등               | 주석, 사용자 정의 타입, 클래스 인스턴스                      |

    ---

    필요하면 JSON의 한계 때문에 생긴 **대안 포맷들**(예: YAML, MessagePack, Protobuf 등)도 정리해줄 수 있어!

    </details>
    <details>
    <summary>Claude 답변</summary>

    JSON은 데이터 교환 형식으로 널리 사용되지만, 표현 가능한 것과 제한사항이 명확합니다.

    ## JSON이 잘 표현할 수 있는 것들

    **기본 데이터 타입**
    - 문자열, 숫자, 불린값(true/false), null
    - 배열과 객체를 통한 중첩 구조
    - 키-값 쌍의 매핑 관계

    **구조화된 데이터**
    - 사용자 정보, API 응답, 설정 파일
    - 계층적 데이터 구조
    - 리스트나 테이블 형태의 데이터

    ```json
    {
    "name": "김철수",
    "age": 30,
    "hobbies": ["독서", "영화감상"],
    "address": {
        "city": "서울",
        "district": "강남구"
    }
    }
    ```

    ## JSON이 표현하기 어려운 것들

    **특수한 데이터 타입**
    - **날짜/시간**: 문자열로만 표현 가능 (`"2024-01-01T10:00:00Z"`)
    - **이진 데이터**: Base64 인코딩으로 우회해야 함
    - **함수나 메서드**: 코드 로직을 직접 저장할 수 없음
    - **순환 참조**: 객체가 자기 자신을 참조하는 구조

    **정밀도 문제**
    - **큰 정수**: JavaScript의 Number 한계로 인한 정밀도 손실
    - **특수 숫자값**: `Infinity`, `NaN`, `-0` 등은 `null`로 변환됨

    **고급 데이터 구조**
    - **주석**: JSON에서는 주석을 지원하지 않음
    - **중복 키**: 같은 키가 여러 번 나오면 마지막 값만 유지
    - **키 순서**: 공식적으로는 순서가 보장되지 않음

    **객체 지향 특성**
    - **클래스 정보**: 객체의 타입이나 메서드 정보 손실
    - **프로토타입 체인**: 상속 관계 표현 불가

    ## 대안이나 해결책

    이런 한계들은 보통 다음과 같이 해결합니다:
    - 날짜는 ISO 8601 문자열 형식 사용
    - 이진 데이터는 Base64 인코딩
    - 복잡한 객체는 직렬화/역직렬화 로직 구현
    - 필요시 JSON5나 YAML 같은 대안 형식 고려

    JSON의 단순함이 장점이자 한계이므로, 용도에 따라 적절히 활용하는 것이 중요합니다.
    
    </details>
    <details>
    <summary>perplexity 답변</summary>

    JSON 포맷에서 **잘 표현할 수 있는 것**은 기본적으로 다음과 같습니다.

    - **문자열, 숫자, 불(boolean), null** 값
    - **배열(array)**: 여러 값을 순서 있게 나열
    - **객체(object)**: 키-값 쌍으로 구성된 집합

    이를 통해 사람과 컴퓨터 모두 읽기 쉬운 구조적 데이터를 손쉽게 주고받을 수 있습니다.[8][10]

    ### JSON으로 표현이 어려운/불가능한 주요 사항

    - **데이터 타입 제한**:  
      JSON은 오직 문자열, 숫자, 불, null, 배열, 객체 타입만 지원합니다.  
      복잡한 데이터 타입(날짜/시간, 바이너리, 함수, undefined, Symbol, NaN, Infinity 등)은 직접 표현이 불가능해서 문자열 등으로 우회 필요.[1][10][8]

    - **숫자 표현 한계**:  
      대부분의 구현체가 IEEE 754 배정도(float64) 기반이어서,  
      매우 큰 정수나 엄청난 정밀도(예: 소수점 이하 20자리)의 숫자는 손실·반올림이 발생할 수 있습니다. NaN, Infinity 등의 특수 값도 RFC 표준상 허용되지 않음.[4][1]

    - **키(프로퍼티) 중복 불가**:  
      하나의 객체 내에 동일 키가 여러 번 나오면 표준은 명확하지 않고, 보통 마지막 값만 반영됩니다.[1][4]

    - **중첩 깊이 및 크기 한계**:  
      이론상 무제한 중첩·크기가 가능하지만, 실제론 파서나 메모리, 플랫폼 제한(64~512단계, 10MB~수십MB 등)이 작동합니다. 너무 깊은 중첩 구조는 지원 불가하거나 성능·안정성이 떨어집니다.[2][3][4]

    - **주석, 순서, 기타 한계**:  
      - 주석(//, /* */)은 허용되지 않음.[4]
      - 객체의 프로퍼티 순서가 보장되지 않는 경우가 많음(배열은 순서 보장).
      - undefined, function, Symbol 등 JavaScript 고유 타입은 포함 불가.[10]

    - **유니코드와 이스케이프**  
      모든 값은 유니코드 문자열이어야 하며, 특수 문자는 반드시 이스케이프됨.[5][1]

    ### 요약

    - **잘 표현되는 것**: 단순 구조 데이터(문자열, 숫자, 논리, 배열, 객체, null).
    - **표현 어려움/불가능**: 날짜/시간, 특수 숫자 값, 이진(bina­ry) 데이터, 함수, 주석, 중복 키, 초과 중첩/크기, 타입 정보가 있는 복합 구조, 순서 지정이 필요한 객체 등.

    복잡하거나 타입 정보가 중요한 데이터, 혹은 바이너리/날짜 정보 등은 **문자열로 인코딩**하거나 별도의 형식(BSON, XML 등)을 고려해야 합니다.

    [1] https://docs.python.org/ko/3.13/library/json.html
    [2] https://sportsinw.tistory.com/142
    [3] https://docs.aws.amazon.com/ko_kr/AmazonElastiCache/latest/dg/json-document-overview.html
    [4] https://cloud.google.com/spanner/docs/working-with-json?hl=ko
    [5] https://www.ibm.com/docs/ko/SSEPGG_11.1.0/com.ibm.swg.im.dbclient.json.doc/doc/c0070418.html
    [6] https://www.reddit.com/r/PostgreSQL/comments/181z3h2/limitations_of_jsonjsonb_usage/?tl=ko
    [7] https://ko.wikipedia.org/wiki/JSON
    [8] https://hahahoho5915.tistory.com/86
    [9] https://gamechangers.tistory.com/18
    [10] https://www.couchbase.com/ko/resources/concepts/json-vs-bson/
    
    </details>
- **수행 소감**
  - 각각의 LLM 특징을 정리해보면 다음과 같다.

    | AI             | 설명 방식               | 강점                    | 단점                    | 유용한 상황               |
    | -------------- | ------------------- | --------------------- | --------------------- | -------------------- |
    | **Claude**     | 부드러운 문서식 서술 + 예시 코드 | 전체 흐름 정리, 가독성, 실무 예시  | 최신 세부 수치나 표준 세부사항은 부족 | 블로그·발표자료, 기초~중급 학습  |
    | **Perplexity** | 핵심 요약 + 근거 출처       | 최신·정확한 정보, 구체 수치, 신뢰성 | 다소 건조하고 예시 부족         | 최신 표준·한계 조사, 보고서·리서치 |
    | **ChatGPT**    | 구조적 설명 + 원리 + 예시 코드 | 맥락 반영, 깊이 있는 원리, 실무 팁 | 최신성은 검색 없인 한계         | 학습·실무 적용, 원리 이해, 실습용 |
  - LLM이 무료인지, 유료인지에 따라 다르고, 질문을 구체적으로 할 수록 답변 내용이 달라지겠지만 내가 한 질문의 답변은 크게 다르지 않았다.
    - 더 많이 써봐야 답변 내용 측면에서 어떤 게 다른지 알 것 같다.
  - 그럼에도 배경 지식이 없을 경우나 출처를 알고 싶은 경우, 관련 자료를 더 찾아보고 싶은 경우엔 **Perplexity**나 **Claude**가 유용하고, 어느 정도 지식을 가지고 있어 요약된 내용을 봐도 이해할 수 있다면 **ChatGPT**가 편리한 것 같다고 느꼈다.


## J105_박다미

- 퀘스트 : 여러 모델 AI에 질문하기
- 선택한 이유
    -  slack으로 다양한 ai를 추천받았지만, 항상 사용하던 GPT외의 AI를 잘 사용해보지 않아와서 이번기회에 사용하며 더 학습할때 더 좋은 AI를 찾아보고 싶다.

---
# 수행하기

## **질문**: “TCP와 UDP의 차이점에 대해 자세히 설명해주세요”

## **🤖 Gemini 답변**

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 컴퓨터 네트워크의 전송 계층(Transport Layer)에서 사용되는 두 가지 핵심 프로토콜입니다. 둘 다 데이터를 패킷(packet) 단위로 캡슐화하여 전송하지만, 작동 방식과 제공하는 기능에 있어 중요한 차이가 있습니다.

아래 표를 통해 두 프로토콜의 주요 특징을 비교하고, 각 특징에 대해 자세히 설명해 드리겠습니다.

| 구분 | TCP (Transmission Control Protocol) | UDP (User Datagram Protocol) |
| --- | --- | --- |
| **연결 방식** | 연결 지향형 (Connection-oriented) | 비연결형 (Connectionless) |
| **신뢰성** | 높음 (신뢰성 있는 데이터 전송 보장) | 낮음 (신뢰성 보장하지 않음) |
| **데이터 순서** | 순서 보장 (데이터 순서대로 재조립) | 순서 보장하지 않음 (도착 순서대로 처리) |
| **속도** | 느림 | 빠름 |
| **전송 제어** | 흐름 제어, 혼잡 제어, 오류 제어 기능 제공 | 흐름 제어, 혼잡 제어 기능 제공하지 않음 |
| **데이터 단위** | 세그먼트(Segment) | 데이터그램(Datagram) |
| **오버헤드** | 큼 (헤더 크기 20바이트) | 작음 (헤더 크기 8바이트) |
| **통신 방식** | 1:1 통신 | 1:1, 1:N, N:N 통신 가능 |
| **주요 사용처** | 웹(HTTP, HTTPS), 파일 전송(FTP), 이메일(SMTP, POP3) | 실시간 스트리밍, 온라인 게임, DNS, VoIP |

---

### 1. 연결 방식 (Connection Type)

- **TCP (연결 지향형)**
    - 데이터를 전송하기 전에 송신자와 수신자 사이에 논리적인 연결을 설정합니다.
    - 이 연결은 **3-way handshake**라는 과정을 통해 이루어집니다.
        1. **SYN (Synchronize)**: 클라이언트가 서버에 연결 요청 패킷을 보냅니다.
        2. **SYN-ACK (Synchronize-Acknowledge)**: 서버가 연결 요청을 수락하고, 클라이언트에게 응답 패킷을 보냅니다.
        3. **ACK (Acknowledge)**: 클라이언트가 서버의 응답을 확인하는 패킷을 보내 연결을 확립합니다.
    - 데이터 전송이 끝난 후에는 **4-way handshake**를 통해 연결을 해제합니다.
    - 이처럼 연결 설정 및 해제 과정이 있기 때문에 통신에 필요한 오버헤드가 발생하지만, 신뢰성을 보장할 수 있습니다.
- **UDP (비연결형)**
    - 별도의 연결 설정 과정 없이 데이터를 즉시 전송합니다.
    - 송신자는 수신자가 데이터를 받을 준비가 되었는지, 제대로 받았는지 확인하지 않고 데이터를 일방적으로 보냅니다.
    - 이러한 단순한 구조 덕분에 TCP보다 빠르고 효율적입니다.

### 2. 신뢰성 (Reliability) 및 순서 보장 (Order Guarantee)

- **TCP (높은 신뢰성)**
    - 데이터 전송의 신뢰성을 보장하기 위해 다양한 메커니즘을 사용합니다.
    - **순서 보장**: 각 패킷(세그먼트)에 순서 번호를 부여하여, 수신자가 데이터가 도착한 순서와  
        관계없이 올바른 순서로 재조립할 수 있게 합니다.
    - **재전송 기능**: 패킷이 손실되거나 손상되면, 수신자는 송신자에게 해당 패킷의 재전송을 요청합니다.   
송신자는 확인 응답(ACK)을 받지 못하면 패킷을 다시 보냅니다.
    - 이러한 기능 덕분에 데이터가 유실되거나 순서가 뒤바뀌는 일 없이 정확하게 전달됩니다.
- **UDP (낮은 신뢰성)**
    - 데이터가 제대로 도착했는지, 순서가 맞는지 확인하지 않습니다.
    - 패킷이 손실되더라도 재전송을 요청하지 않으며, 순서가 뒤바뀌어 도착해도 그대로 처리합니다.
    - 따라서 데이터의 신뢰성과 순서 보장이 중요하지 않은 애플리케이션에 적합합니다.

### 3. 속도 및 오버헤드 (Speed & Overhead)

- **TCP (느림)**
    - 연결 설정, 해제, 재전송, 순서 보장 등 여러 신뢰성 기능을 위한 추가적인 처리가 필요합니다.
    - 이러한 기능들은 헤더에 많은 정보를 포함하게 되어 데이터 전송량 대비 오버헤드가 큽니다(TCP 헤더: 최소 20바이트).
    - 따라서 UDP에 비해 상대적으로 속도가 느립니다.
- **UDP (빠름)**
    - 신뢰성 관련 기능이 없기 때문에 헤더가 매우 단순하고 작습니다(UDP 헤더: 8바이트).
    - 추가적인 처리 과정이 없어 데이터 전송 속도가 빠르고 네트워크 부하가 적습니다.

### 4. 사용 사례

- **TCP**
    - 데이터의 정확성과 순서가 매우 중요한 서비스에 사용됩니다.
    - 예: 웹 브라우징(HTTP, HTTPS), 파일 전송(FTP), 이메일(SMTP, POP3) 등
    - 데이터 패킷이 하나라도 손실되면 전체 서비스에 문제가 발생할 수 있는 경우에 적합합니다.
- **UDP**
    - 데이터의 신뢰성보다는 속도와 효율성이 중요한 실시간 서비스에 사용됩니다.
    - 예: 실시간 동영상 스트리밍, 온라인 게임, 음성 통화(VoIP), DNS(Domain Name System) 등
    - 약간의 데이터 손실이 발생하더라도 서비스의 연속성에 큰 영향을 주지 않는 경우에 적합합니다.   
예를 들어, 실시간 스트리밍 중 패킷 몇 개가 손실되면 순간적으로 화면이 깨지거나 소리가 끊기지만, 전체 흐름은 계속 이어지는 것과 같습니다.

## **🤖 ChatGPT답변**

TCP와 UDP는 **전송 계층 (Transport Layer)**에서 사용되는 대표적인 프로토콜입니다.    
 각각의 특징과 차이점을 아래와 같이 **구조, 기능, 사용 사례** 중심으로 상세히 정리해 드리겠습니다.

---

## 📦 1. 개요 비교

| 항목 | TCP (Transmission Control Protocol) | UDP (User Datagram Protocol) |
| --- | --- | --- |
| 연결 방식 | 연결지향 (Connection-oriented) | 비연결지향 (Connectionless) |
| 신뢰성 | 보장됨 (데이터 손실 보정, 순서 보장) | 보장되지 않음 (손실, 순서 무관) |
| 속도 | 느림 (오버헤드 큼) | 빠름 (오버헤드 적음) |
| 전송 단위 | 바이트 스트림 (stream) | 데이터그램 (datagram) |
| 흐름/혼잡 제어 | 있음 | 없음 |
| 사용 예시 | 웹, 이메일, 파일 전송 | 영상 스트리밍, 게임, VoIP |

---

## 🧱 2. 구조적 차이

### TCP 구조 특징:

- **3-way Handshake**로 연결 설정
    
    ```
    클라이언트: SYN →
    서버: SYN + ACK →
    클라이언트: ACK → 연결 성립
    ```
    
- *시퀀스 번호 (Sequence Number)**를 기반으로 순서 보장
- **ACK 응답**을 받아야 다음 데이터 전송
- **슬라이딩 윈도우** 기반 흐름 제어

### UDP 구조 특징:

- **연결 설정 없음**: 데이터를 그냥 보냄
- **헤더가 간단함** (8바이트 고정)
- **수신 확인 없음**: 보내고 끝
- **패킷 순서나 중복 처리 없음**

---

## 🔒 3. 신뢰성 및 에러 처리

| 항목 | TCP | UDP |
| --- | --- | --- |
| 전송 보증 | 보낸 데이터가 반드시 도착 | 도착 여부 보장 안 됨 |
| 순서 보장 | 있음 (시퀀스 번호로 순서 재구성) | 없음 (순서 바뀔 수 있음) |
| 재전송 | 손실 시 재전송 | 없음 |
| 오류 검출 | 체크섬 + 재전송 | 체크섬만 있음 (손실되면 무시) |

---

## 🚀 4. 속도 및 성능

- **TCP**: 느리지만 정확함 → 안정성이 필요한 작업에 적합
- **UDP**: 빠르지만 불완전함 → 실시간성이 중요한 작업에 적합

예:

- TCP → 웹사이트, 이메일, 파일 다운로드 (데이터 손실 없어야 함)
- UDP → 실시간 게임, 음성/영상 통화 (일부 손실 무관)

---

## 🧑‍💻 5. 대표 포트 예시

| 서비스 | 프로토콜 | 포트 번호 |
| --- | --- | --- |
| HTTP | TCP | 80 |
| HTTPS | TCP | 443 |
| FTP | TCP | 20, 21 |
| DNS | UDP (보통) | 53 |
| DHCP | UDP | 67, 68 |
| VoIP | UDP | 다양함 (보통 5060 등) |

---

## 🎮 6. 사용 예시 상황

### TCP 적합한 경우:

- **은행 사이트 로그인** (데이터 정확성 필요)
- **파일 다운로드** (손실 없이 완벽한 수신 필요)
- **웹 서핑** (HTTP, HTTPS는 TCP 기반)

### UDP 적합한 경우:

- **줌(Zoom) 통화** (음성이 조금 깨져도 실시간성 우선)
- **온라인 게임** (몇 프레임 손실돼도 빠르게 전송이 더 중요)
- **IPTV / 유튜브 스트리밍** (버퍼링 최소화 우선)

---

## 🧠 요약

| 항목 | TCP | UDP |
| --- | --- | --- |
| 연결 방식 | 연결 필요 | 연결 불필요 |
| 신뢰성 | 높음 | 낮음 |
| 속도 | 느림 | 빠름 |
| 오버헤드 | 큼 | 작음 |
| 용도 | 안정성 중요 | 실시간성 중요 |

---

## 비교하고 정리하기

### **AI1 (Gemini)**

아주 구조적이고 체계적인 표 + 각 항목에 대한 자세한 설명 제공

→ 마치 “대학 교재처럼” 정리된 느낌

### **AI2 (ChatGPT)**

[내가 위에서 작성한 답변]

핵심 요점을 표로 요약하고, 실무 관점에서 사용 사례나 통신 흐름에 중점

→ “실전에서 쓸 수 있는 설명 중심” 느낌

---

## 비교 분석

### 1. 어떤 AI가 더 적절했나요?

- **Gemini**는 이론적인 관점에서 **중립적이고 사전처럼 체계적**인 설명을 제공해주었습니다.
- **ChatGPT**는 TCP와 UDP의 차이점뿐 아니라,   
  실제 **네트워크 애플리케이션 개발 시 어떤 프로토콜을 언제 써야 하는지**에 대한 **맥락 중심** 설명이 인상적이었습니다.

### 2. 어떤 기준으로 비교했나요?

| 비교 항목 | Gemini | ChatGPT |
| --- | --- | --- |
| 구조화 정도 | 표와 항목별 정리로 깔끔함 | 요약 + 실무 흐름 위주로 설명 |
| 실전 활용도 | 다소 추상적 | 개발자 관점에서 명확함 |
| 설명 스타일 | 백과사전/교재 느낌 | 튜토리얼/멘토 느낌 |
| 예시/적용 사례 | 일부 포함 | 풍부하게 제공 |

---

## ✍️ 의견 정리

> Gemini는 정형화된 정보를 정확히 정리해주어서 문서화나 리포트 작성에 적합했습니다.  
반면 ChatGPT는 개발자의 시야로 TCP/UDP의 선택 기준을 알려주고, 설명이 상황 중심이라서 더 이해가 쉬웠습니다.
> 
> 
> 그래서 **“처음 배우는 입문자”라면 Gemini, “실제 코딩이나 시스템 설계에 적용해야 하는 사람”이라면 ChatGPT**가 더 유용할 수 있다고 생각합니다.
>


---

## J260_지은미

- 퀘스트 : AI를 활용해 스트레스가 풀릴 수 있는 춤 추천받기
- 선택한 이유 
    - 학습을 진행하는 과정에서 스트레스를 해소하는데 춤을 춰보는것도 좋은 것 같다.
    - 과제 과정에서 피곤할 때 AI에게 추천받아 수행하며 즐겁게 미션을 진행하고 싶다.

## S009_김주희

- 퀘스트: AI를 활용해 스트레스가 풀릴 수 있는 춤 추천받기
    - 춤은 헤드뱅잉으로 하겠습니다. 대신 AI를 활용해 스트레스가 풀리고 헤드뱅잉하기 좋은 락 음악을 추천받겠습니다.
- 선택한 이유:
    - 퀘스트의 목적이 춤으로 스트레스 해소라면 나에게 락과 헤드뱅잉만한 게 없는 것 같다. 이번주 주말에도 락 페스티벌 가는데 퀘스트를 수행하며 여운을 즐기고 싶다.
- 퀘스트 수행 결과:
    <img width="522" height="961" alt="Image" src="https://github.com/user-attachments/assets/e79a9433-a704-42ed-abc6-8d8988ace78e" />
- 소감:
    - 챌린지 마지막 미션을 진행하며 스트레스가 최고조라 새벽에 미션을 수행했다. 역시 스트레스 풀기엔 헤드뱅잉!👍 댓글로 노래 추천해주신 분들도 계셔서, 덕분에 좋은 노래를 알아가기도 했다.🎸🔥

